"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stream_1 = require("stream");
const debug = require('debug')('pond');
function pond(source = null, callback = null, options) {
    return new Pond(source, callback, options);
}
exports.default = pond;
class Pond extends stream_1.Writable {
    constructor(source, callback, options) {
        super(options);
        this._buffers = [];
        this._usePromise = false;
        this._promise = new Promise((resolve, reject) => {
            let hasError = false;
            this.once('finish', () => postponeForError(() => {
                if (hasError)
                    return;
                const buffer = Buffer.concat(this._buffers);
                debug('finished collecting %s bytes', buffer.length);
                if ('function' === typeof this._callback) {
                    this._callback(null, buffer);
                    debug('triggered callback without error');
                }
                if ('function' === typeof this._onspooned) {
                    this._onspooned(buffer);
                    debug('spooned');
                }
                if (this._usePromise) {
                    resolve(buffer);
                    debug('resolved');
                }
            }));
            this.once('error', (err) => {
                if ('function' === typeof this._callback) {
                    this._callback(err);
                    debug('callback error emited by self');
                }
                if (this._usePromise) {
                    reject(err);
                    debug('rejected');
                }
            });
            this.on('pipe', (source) => {
                source.once('error', (e) => {
                    hasError = true;
                    this.destroy(e);
                });
            });
        });
        if (callback) {
            this._callback = callback;
        }
        debug('setup finished');
        if (source) {
            source.pipe(this);
            debug('piped source');
        }
    }
    _write(chunk, encoding, callback) {
        this._buffers.push(chunk);
        debug('buffered chunk %s bytes', chunk.length);
        callback();
    }
    spoon(handler) {
        if ('function' === typeof handler) {
            this._onspooned = handler;
            debug('attached spoon handler');
        }
        else {
            this._usePromise = true;
            debug('spoon as a Promise');
            return this._promise;
        }
    }
}
function postponeForError(callback) {
    process.nextTick(() => process.nextTick(callback));
}
