"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const decompress_tar_1 = __importDefault(require("@xingrz/decompress-tar"));
const decompress_tarbz2_1 = __importDefault(require("@xingrz/decompress-tarbz2"));
const decompress_targz_1 = __importDefault(require("@xingrz/decompress-targz"));
const decompress_tarzst_1 = __importDefault(require("@xingrz/decompress-tarzst"));
const decompress_unzip_1 = __importDefault(require("@xingrz/decompress-unzip"));
const stream_1 = require("stream");
const util_1 = require("util");
const strip_dirs_1 = __importDefault(require("strip-dirs"));
const pipeline = (0, util_1.promisify)(stream_1.pipeline);
async function runPlugins(input, opts) {
    const plugins = opts.plugins || [];
    if (plugins.length === 0) {
        return [];
    }
    const files = await Promise.all(plugins.map(x => x(input, opts)));
    return files.reduce((a, b) => a.concat(b));
}
async function safeMakeDir(dir, realOutputPath) {
    let realParentPath;
    try {
        realParentPath = await (0, fs_extra_1.realpath)(dir);
    }
    catch (e) {
        const parent = (0, path_1.dirname)(dir);
        realParentPath = await safeMakeDir(parent, realOutputPath);
    }
    if (!realParentPath.startsWith(realOutputPath)) {
        throw new Error('Refusing to create a directory outside the output path.');
    }
    await (0, fs_extra_1.mkdirs)(dir);
    return await (0, fs_extra_1.realpath)(dir);
}
async function preventWritingThroughSymlink(destination) {
    let symlinkPointsTo;
    try {
        symlinkPointsTo = await (0, fs_extra_1.readlink)(destination);
    }
    catch (_) {
        // Either no file exists, or it's not a symlink. In either case, this is
        // not an escape we need to worry about in this phase.
        return;
    }
    if (symlinkPointsTo) {
        throw new Error('Refusing to write into a symlink');
    }
    // No symlink exists at `destination`, so we can continue
}
function applyFileMappers(file, opts) {
    const { strip, filter, map } = opts;
    if (typeof strip === 'number' && strip > 0) {
        file = Object.assign(file, { path: (0, strip_dirs_1.default)(file.path, strip) });
        if (file.path === '.') {
            return false;
        }
    }
    if (typeof filter === 'function') {
        if (!filter(file)) {
            return false;
        }
    }
    if (typeof map === 'function') {
        file = map(file);
    }
    return true;
}
async function extractFile(input, output, opts) {
    if (output) {
        opts.fileWriter = (file, input) => outputFile({ ...file }, input, output, opts);
    }
    const files = await runPlugins(input, opts);
    return files.filter(file => applyFileMappers(file, opts));
}
async function outputFile(file, input, output, opts) {
    if (!applyFileMappers(file, opts)) {
        input === null || input === void 0 ? void 0 : input.resume();
        return;
    }
    const dest = (0, path_1.join)(output, file.path);
    const now = new Date();
    await (0, fs_extra_1.mkdirs)(output);
    const realOutputPath = await (0, fs_extra_1.realpath)(output);
    if (file.type === 'directory') {
        await safeMakeDir(dest, realOutputPath);
        await (0, fs_extra_1.utimes)(dest, now, new Date(file.mtime));
        return;
    }
    // Attempt to ensure parent directory exists (failing if it's outside the output dir)
    await safeMakeDir((0, path_1.dirname)(dest), realOutputPath);
    if (file.type === 'file') {
        await preventWritingThroughSymlink(dest);
    }
    const realDestinationDir = await (0, fs_extra_1.realpath)((0, path_1.dirname)(dest));
    if (!realDestinationDir.startsWith(realOutputPath)) {
        throw new Error('Refusing to write outside output directory: ' + realDestinationDir);
    }
    if (file.type === 'link') {
        await (0, fs_extra_1.link)((0, path_1.join)(output, file.linkname), dest);
    }
    else if (file.type === 'symlink') {
        if (process.platform === 'win32') {
            await (0, fs_extra_1.link)((0, path_1.join)(output, file.linkname), dest);
        }
        else {
            await (0, fs_extra_1.symlink)(file.linkname, dest);
        }
    }
    else if (file.type === 'file' && input) {
        await pipeline(input, (0, fs_1.createWriteStream)(dest, { mode: file.mode }));
        await (0, fs_extra_1.utimes)(dest, now, new Date(file.mtime));
    }
}
async function decompress(input, output, opts) {
    if (typeof input !== 'string' && !Buffer.isBuffer(input)) {
        throw new TypeError('Input file required');
    }
    if (typeof output == 'object') {
        opts = output;
        output = null;
    }
    opts = {
        plugins: [
            (0, decompress_tar_1.default)(),
            (0, decompress_tarbz2_1.default)(),
            (0, decompress_targz_1.default)(),
            (0, decompress_tarzst_1.default)(),
            (0, decompress_unzip_1.default)()
        ],
        ...opts,
    };
    const buf = typeof input === 'string' ? await (0, fs_extra_1.readFile)(input) : input;
    return extractFile(buf, output || null, opts);
}
exports.default = decompress;
